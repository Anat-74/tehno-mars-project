import{v as e,k as a,l as t,m as n,I as s,b as r,j as o,c as u,n as i,o as l,p as c}from"./server.mjs";import{W as d}from"../nitro/nitro.mjs";import"../routes/renderer.mjs";import"../_/shared.esm-bundler.mjs";import"node:buffer";import"node:timers";import"node:events";import"node:process";import"node:util";const m={trailing:!0};function debounce(e,a=25,t={}){if(t={...m,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let n,s,r,o,u=[];const applyFn=(a,n)=>(r=async function(e,a,t){return await e.apply(a,t)}(e,a,n),r.finally((()=>{if(r=null,t.trailing&&o&&!s){const e=applyFn(a,o);return o=null,e}})),r);return function(...e){return r?(t.trailing&&(o=e),r):new Promise((r=>{const o=!s&&t.leading;clearTimeout(s),s=setTimeout((()=>{s=null;const a=t.leading?n:applyFn(this,e);for(const e of u)e(a);u=[]}),a),o?(n=applyFn(this,e),r(n)):u.push(r)}))}}function useAsyncData(...t){var s;const r="string"==typeof t[t.length-1]?t.pop():void 0;"string"==typeof t[0]||"object"==typeof t[0]||"function"==typeof t[0]&&"function"==typeof t[1]||t.unshift(r);let[o,i,l={}]=t;const c=e.computed((()=>e.toValue(o)));if("string"!=typeof c.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof i)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const d=a();l.server??(l.server=!0),l.default??(l.default=()=>n.value),l.getCachedData??(l.getCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0),l.lazy??(l.lazy=!1),l.immediate??(l.immediate=!0),l.deep??(l.deep=n.deep),l.dedupe??(l.dedupe="cancel"),l._functionName,d._asyncData[c.value];const m=l.getCachedData(c.value,d,{cause:"initial"});(null==(s=d._asyncData[c.value])?void 0:s._deps)||(d._asyncData[c.value]=function(a,t,s,r,o){var i;(i=a.payload._errors)[t]??(i[t]=n.errorValue);const l=s,c=r.deep?e.ref:e.shallowRef,d=null!=o,m={data:c(d?o:r.default()),pending:e.computed((()=>"pending"===m.status.value)),error:e.toRef(a.payload._errors,t),status:e.shallowRef("idle"),execute:(s={})=>{if(a._asyncDataPromises[t]){if("defer"===(i=s.dedupe??r.dedupe)||!1===i)return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}var i;{const e="initial"===s.cause?o:r.getCachedData(t,a,{cause:s.cause??"refresh:manual"});if(null!=e)return a.payload.data[t]=m.data.value=e,m.error.value=n.errorValue,m.status.value="success",Promise.resolve(e)}m.status.value="pending";const c=new Promise(((e,t)=>{try{e(l(a))}catch(e){t(e)}})).then((async e=>{if(c.cancelled)return a._asyncDataPromises[t];let s=e;r.transform&&(s=await r.transform(e)),r.pick&&(s=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(s,r.pick)),a.payload.data[t]=s,m.data.value=s,m.error.value=n.errorValue,m.status.value="success"})).catch((n=>{if(c.cancelled)return a._asyncDataPromises[t];m.error.value=u(n),m.data.value=e.unref(r.default()),m.status.value="error"})).finally((()=>{c.cancelled||delete a._asyncDataPromises[t]}));return a._asyncDataPromises[t]=c,a._asyncDataPromises[t]},_execute:debounce(((...e)=>m.execute(...e)),0,{leading:!0}),_default:r.default,_deps:0,_hash:void 0,_off:a.hook("app:data:refresh",(async e=>{e&&!e.includes(t)||await m.execute({cause:"refresh:hook"})}))};return m}(d,c.value,i,l,m));d._asyncData[c.value]._deps++;if(!1!==l.server&&d.payload.serverRendered&&l.immediate){const a=d._asyncData[c.value].execute({cause:"initial",dedupe:l.dedupe});e.getCurrentInstance()?e.onServerPrefetch((()=>a)):d.hook("app:created",(async()=>{await a}))}const p={data:writableComputedRef((()=>d._asyncData[c.value].data)),pending:writableComputedRef((()=>d._asyncData[c.value].pending)),status:writableComputedRef((()=>d._asyncData[c.value].status)),error:writableComputedRef((()=>d._asyncData[c.value].error)),refresh:(...e)=>d._asyncData[c.value].execute(...e),execute:(...e)=>d._asyncData[c.value].execute(...e),clear:()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0);a in e.payload._errors&&(e.payload._errors[a]=n.errorValue);e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=n.errorValue,e._asyncData[a].status.value="idle");a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(d,c.value)},f=Promise.resolve(d._asyncDataPromises[c.value]).then((()=>p));return Object.assign(f,p),f}function writableComputedRef(a){return e.computed({get:()=>a().value,set(e){a().value=e}})}let p=!1;async function loadIcon(e,a){if(!e)return null;!function(e){if(p)return;const a=JSON.parse('[{"prefix":"my-icon","icons":{"icon-by-regular":{"width":324,"height":365,"body":"\x3c!-- Generator: Sketch 60.1 (88133) - https://sketch.com --\x3e\\n    <title>BYNregularBlack</title>\\n    <desc>Created with Sketch.</desc>\\n    <defs>\\n        <path d=\\"M291.17,0.86 L291.17,41.66 L90.23,41.66 L90.23,83.819 L255,83.82 L255,124.62 L90.23,124.619 L90.23,148.76 L211.61,148.76 L212.6887,148.7628 C248.2017,148.9479 275.4671,158.297 294.485,176.81 C313.695,195.51 323.3,222.37 323.3,257.39 C323.3,292.07 313.695,318.675 294.485,337.205 C275.275,355.735 247.65,365 211.61,365 L211.61,365 L41.78,365 L41.78,124.619 L0,124.62 L0,83.82 L41.78,83.819 L41.78,0.86 L291.17,0.86 Z M195.8,189.56 L90.23,189.56 L90.23,324.2 L195.8,324.2 C248.84,324.2 275.36,301.93 275.36,257.39 C275.36,212.17 248.84,189.56 195.8,189.56 L195.8,189.56 Z\\" id=\\"path-1\\"></path>\\n    </defs>\\n    <g id=\\"Page-1\\" stroke=\\"none\\" stroke-width=\\"1\\" fill=\\"none\\" fill-rule=\\"evenodd\\">\\n        <g id=\\"BYNregularBlack\\">\\n            <g>\\n                <mask id=\\"mask-2\\" fill=\\"white\\">\\n                    <use xlink:href=\\"#path-1\\"></use>\\n                </mask>\\n                <g id=\\"Clip-2\\"></g>\\n                <polygon id=\\"Fill-1\\" fill=\\"#000000\\" mask=\\"url(#mask-2)\\" points=\\"-5 -4.14 328.3 -4.14 328.3 370 -5 370\\"></polygon>\\n            </g>\\n        </g>\\n    </g>"}}}]');for(const t of a)for(const[a,n]of Object.entries(t.icons))e(t.prefix?t.prefix+":"+a:a,n);p=!0}(c);const t=i(e);if(t)return t;let n;const s=l(e).catch((()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null)));return a>0?await Promise.race([s,new Promise((t=>{n=setTimeout((()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()}),a)}))]).finally((()=>clearTimeout(n))):await s,i(e)}function useResolvedName(a){const n=t().icon,s=(n.collections||[]).sort(((e,a)=>a.length-e.length));return e.computed((()=>{var e;const t=a(),r=t.startsWith(n.cssSelectorPrefix)?t.slice(n.cssSelectorPrefix.length):t,o=(null==(e=n.aliases)?void 0:e[r])||r;if(!o.includes(":")){const e=s.find((e=>o.startsWith(e+"-")));return e?e+":"+o.slice(e.length+1):o}return o}))}function resolveCustomizeFn(e,a){if(!1!==e)return!0===e||null===e?a:e}const f="NUXT_ICONS_SERVER_CSS";const y=e.defineComponent({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(n){const s=a(),u=t().icon,i=e.computed((()=>n.name?u.cssSelectorPrefix+n.name:"")),l=e.computed((()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(i.value)));return e.onServerPrefetch((async()=>{var e;{const a=r().icon||{};if(!(null==(e=null==a?void 0:a.serverKnownCssClasses)?void 0:e.includes(i.value))){const e=await loadIcon(n.name,u.fetchTimeout).catch((()=>null));if(!e)return null;let a=s.vueApp._context.provides[f];if(a||(a=s.vueApp._context.provides[f]=new Map,s.runWithContext((()=>{o({style:[()=>{let e=Array.from(a.values()).sort().join("");return u.cssLayer&&(e=`@layer ${u.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),n.name&&!a.has(n.name)){const t=function(e,a=!0){let t=l.value;u.cssWherePseudo&&(t=`:where(${t})`);const s=d(e,{iconSelector:t,format:"compressed",customise:resolveCustomizeFn(n.customize,u.customize)});return u.cssLayer&&a?`@layer ${u.cssLayer} { ${s} }`:s}(e,!1);a.set(n.name,t)}return null}}})),()=>e.h("span",{class:["iconify",i.value]})}}),v=e.defineComponent({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(n,{slots:r}){a();const o=t().icon,u=useResolvedName((()=>n.name)),i="i-"+u.value;return u.value&&e.onServerPrefetch((async()=>{await useAsyncData(i,(async()=>await loadIcon(u.value,o.fetchTimeout)),{deep:!1})})),()=>e.h(s,{icon:u.value,ssr:!0,customise:resolveCustomizeFn(n.customize,o.customize)},r)}}),h=e.defineComponent({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(n,{slots:s}){const r=a(),o=t().icon,u=useResolvedName((()=>n.name)),i=e.computed((()=>{var e;return(null==(e=r.vueApp)?void 0:e.component(u.value))||("svg"===(n.mode||o.mode)?v:y)})),l=e.computed((()=>{const e=n.size||o.size;return e?{fontSize:Number.isNaN(+e)?e:e+"px"}:null}));return()=>e.h(i.value,{...o.attrs,name:u.value,class:o.class,style:l.value,customize:n.customize},s)}}),g=Object.freeze(Object.defineProperty({__proto__:null,default:h},Symbol.toStringTag,{value:"Module"}));export{h as _,g as i,useAsyncData as u};
//# sourceMappingURL=index-CpWcOAco.mjs.map
